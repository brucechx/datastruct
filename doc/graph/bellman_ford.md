# 贝尔曼—福特算法
对图进行最多V-1次松弛操作， 得到所有可能的最短路径。

其优于迪克斯特拉算法是边的权值可以为负数，实现简单，缺点是时间复杂度过高，O(VE)。

可检测负环路的情况，1+(-2) = -1<0即为负环路。

## 算法思路：
- 初始化时将起点s到各个定点v的距离dist(s->v)赋值为无穷大，dist(s->s)为0
- 后续进行最多n-1次遍历操作(n为顶点个数)对所有的边进行松弛操作：
    + 松弛操作：
        * 以ab为例，若dist(a)代表起点s到达a点所需要花费的总数，dist(b)代表起点s到达b点所需要花费的总数，weight(ab)代表边ab的权重，
        * 若存在：(dist(a)+weight(ab)<dist(b))
        * 则说明存在到b的最短路径，s->...->a->b，更新b点的总花费为(dist(a)+weight(ab)),父节点为a。
- 遍历都结束后，若再进行一次遍历，还能得到s到某些节点更短的路径的话，说明存在负环路。

思路上与Dijkstra最大的不同是每次都是从源点s重新出发进行"松弛"更新操作，而Dijkstra则是从源点出发向外扩逐个处理相邻的节点，不会去重复处理节点，可看出Dijkstra效率更高。

## Dijkstra VS Bellman-Ford：
- Dijkstra是贪心算法选点，bellman-ford是动态规划选边。
- 广度优先算法BFS主要适用于无权重图，搜索出源点到终点步骤最小的路径，有向图存在权重时，不再适应。
- Dijkstra主要用于有权重有向图搜索出最短路径，不适应有负权重的情况。
- Bellman-Ford主要用于存在负权重的有向图中(没有负权重也可以用，效率比Dijkstra低)，搜索出源点到各个节点的最短路径
- Bellman-Ford可以判断出图是否存在负环路，但存在负环路情况下不支持计算出各个节点的最短路径。

## 参考
- [Bellman-Ford算法原理及练习 || LeetCode 787](https://zhuanlan.zhihu.com/p/36295603)
- [github](https://github.com/desicochrane/bellman-ford)